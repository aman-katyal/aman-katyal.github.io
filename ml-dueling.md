---
layout: default
title: "ML Gesture Dueling System"
permalink: /projects/ml-dueling
printable: true
order: 4
---


# ML-Powered Gesture Dueling System: A Real-Time Embedded AI Implementation

**Project Role:** Lead Embedded Systems Engineer
**Core Technologies:** RP2350 (Dual-Core ARM Cortex-M33), Edge Impulse (TFLite Micro), C/C++, KiCad (PCB Design), IR PWM Encoding, ABS 3D Printing, DMA, PIO.

## I. System Overview & Problem Statement

Traditional gesture-based gaming systems often suffer from high latency and low accuracy due to the overhead of processing complex sensor data on a single core. In a competitive dueling environment, even a 50ms delay can break immersion. This project solves these challenges by implementing an asymmetric dual-core architecture on the RP2350, offloading heavy Machine Learning (ML) inference to a dedicated "brain" core while maintaining a jitter-free game loop on the "body" core.

The system is split into two primary hardware units:

1. **The Handheld Wand:** Captures high-fidelity motion data and provides haptic feedback.
2. **The Chest-Mounted Unit:** Houses the main PCB, the 16x16 LED display, the IR receiver, and a high-capacity power bank.

---

## II. Hardware Architecture & PCB Design

### Custom PCB Design (KiCad)

I designed a custom PCB in KiCad to interface the RP2350 with multiple high-speed peripherals.

* **Shared I2C Bus:** The BNO08x IMU and the DRV2605 Haptic Driver share `i2c0` at 400kHz.
* **Infrared Subsystem:** A dedicated IR LED driven by a high-current transistor for 8-meter range, and an IR receiver tuned to a 38kHz carrier frequency.
* **Power Delivery:** The system is powered via a 20,000 mAh USB-C power bank, providing approximately 10 hours of runtime even when the 256-LED matrix is at peak 2A consumption.

### Mechanical Design & Fabrication

* **Two-Unit Ergonomics:** By separating the battery and display into a chest unit, the wand remains lightweight and maneuverable for rapid casting.
* **3D Printing:** Enclosures were prototyped in PLA for fit-testing and printed in **ABS** for the final version to withstand the stresses of competitive play and the heat generated by the LED matrix.

**[Placeholder: Insert KiCad Schematic and PCB 3D Renders]**
**[Placeholder: Insert High-Res Photos of the ABS Printed Wand and Chest Units]**

---

## III. Firmware Architecture: Dual-Core Multiprocessing

The system leverages the RP2350’s dual cores to parallelize the AI pipeline. This ensures that the sensor polling and IR communications are never blocked by the computationally intensive inference engine.

### Core 0: The "Body" (Real-Time Control)

Core 0 handles all I/O and time-sensitive game logic.

* **High-Frequency Polling:** Polls the BNO08x at **74Hz** using stabilized rotation vectors (`SH2_ARVR_STABILIZED_RV`) to eliminate gyro drift.
* **Ring Buffer Management:** Implements a sliding window using a circular buffer to store 6-axis data (Acc X/Y/Z and Yaw/Pitch/Roll).
* **IR Handling:** Manages the interrupt-driven IR receiver and the PWM-based transmitter state machine.

### Core 1: The "Brain" (AI Accelerator)

Core 1 is dedicated to the **Edge Impulse inference engine**. It remains in a low-power wait state until Core 0 signals that a new window of data is ready via the hardware FIFO.

### Inter-Core Data Exchange

When a classification is requested, Core 0 "unrolls" the ring buffer into a flat exchange buffer and pushes a trigger to the FIFO.

```c
// Ring buffer unrolling logic for Core 1 consumption
void rb_unroll_to_exchange() {
    int count = EI_FEATURE_SIZE;
    int start_idx = rb_head - count;
    if (start_idx < 0) {
        start_idx += RING_BUFFER_SIZE;
        int part_a = RING_BUFFER_SIZE - start_idx;
        memcpy(exchange_buffer, &sensor_ring_buffer[start_idx], part_a * sizeof(float));
        memcpy(&exchange_buffer[part_a], &sensor_ring_buffer[0], (count - part_a) * sizeof(float));
    } else {
        memcpy(exchange_buffer, &sensor_ring_buffer[start_idx], count * sizeof(float));
    }
}

```

---

## IV. Motion Intelligence & Machine Learning

### The Inference Pipeline

* **DSP Window:** A 1650ms window capturing 6 axes of movement results in a feature size of approximately 732 values per inference.
* **Model Performance:** Using a TensorFlow Lite Micro model, the system achieves **96% accuracy** for gestures like "Aguamenti" and "Stupefy."
* **Anomaly Rejection:** To prevent false positives from casual wand movement, I integrated a **Gaussian Mixture Model (GMM)** anomaly score. A spell is only considered valid if the score remains below a specific threshold (e.g., 2.3 for Aguamenti).

### The "Spell Bucket" Algorithm

To smooth out AI jitter, I implemented a custom trigger algorithm. Each valid inference adds to a "spell score." Once the score hits a target (e.g., 7), the spell fires.

* **SPELL_TRIGGER_TARGET (7):** Requires multiple consistent inferences to fire.
* **SPELL_DECAY_RATE (2):** Rapidly drains the score if the AI sees non-matching movements, preventing accidental casts.

---

## V. Digital Combat: Custom IR Protocol

### Non-Blocking IR Transmission

The IR transmitter uses a state machine driven by a PWM slice and a hardware timer. This allows the system to send an 8-meter IR burst without stalling the game loop.

* **Carrier Frequency:** 38kHz modulation.
* **Protocol:** Custom NEC-based frame containing a `PLAYER_ID` (address) and a `SPELL_CMD` (command).

### Interrupt-Driven Reception

The receiver uses a GPIO callback to measure MARK and SPACE durations at the microsecond level.

```c
// IR state machine for decoding signals without blocking
void ir_gpio_callback(uint gpio, uint32_t event_mask) {
    uint64_t now_us = time_us_64();
    uint32_t duration_us = (uint32_t)(now_us - g_ir_params.last_event_time_us);
    
    switch (g_ir_params.state) {
        case IR_STATE_MARK:
            if (event_mask & GPIO_IRQ_EDGE_RISE) {
                g_ir_params.raw_buf[g_ir_params.raw_len++] = duration_us;
                g_ir_params.state = IR_STATE_SPACE;
            }
            break;
        // ... state machine continues
    }
}

```

---

## VI. Interactive Feedback & Visuals

### WS2812 Matrix & DMA

The 16x16 matrix is driven using the RP2350’s **PIO (Programmable I/O)** and **DMA**. This allows for complex animations (fireworks, ripples, and a dynamic health bar) without consuming CPU cycles.

* **Health Bar:** Dynamically updates based on received IR hits.
* **Loser Screen:** A dedicated animation plays when health reaches zero, followed by a system reset.

### Tactile Immersion

The DRV2605 driver provides distinct haptic effects:

* **Cast Feedback:** A sharp "click" sensation upon successful gesture recognition.
* **Hit Feedback:** A powerful, sustained vibration to simulate taking damage.

---

## VII. Technical Specifications Summary

* **Inference Latency:** < 5ms (Core 1).
* **Sensor Polling:** 74Hz (Core 0).
* **IR Effective Range:** 8 Meters at 38kHz.
* **Battery Life:** ~10 Hours (20k mAh Power Bank).
* **Safety Mechanics:** `ALLOW_SELF_HIT` toggle for single-unit testing.
* **Cool-downs:** 10-second Shield cooldown to prevent spamming.

**[Placeholder: Insert Video of a Live 1v1 Duel showing Gesture -> Hit -> Haptic/Visual Feedback]**
**[Placeholder: Insert Graph showing the IMU sensor window vs. AI Confidence Scores]**
